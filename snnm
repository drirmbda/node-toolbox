#!/bin/bash

#global variables readonly
readonly VERSION="0.2.5"
readonly ARGS=( "$@" )
OWNER_DISCORD_ID="none"                   # Disabled if "none". Set to your own ID as default (sorry if your ID is none)
STARTPORT=1000                            # Default lower end of port range, inclusive
ENDPORT=65535                             # Default upper end of port range, inclusive
WAIT_SECS=10                              # Default wait between new node starts
SAFENODEPATH="$HOME/.local/bin/safenode"  # Default safenode binary, full path
NODE_DIR="$HOME/.local/share/safe/node/"  # Default location of peer_id directories
NODE_ARCHIVE_DIR="$NODE_DIR/../node_archive/"  # location to archive peer-id directories out of the way
#NODE_DIR_NODEMGR="/var/log/safenode/"    # Default location of peer_id dirs when started with safenode-manager
NODE_MANAGER=""                           # "y" indicates selection of safenode-manager use-case, not the default
INTERACTIVE=""                            # "y" indicates selection of interactive mode with TUI or GUI, not the default
NO_SCREEN="y"                             # "y" indicates running of new nodes without using screen utility
COMMAND=""                                # "y" indicates a specific function was selected
RPC_PROTO_PATH="$HOME"                    # Default location of .proto files compatible with safenode binary
RPC_ENABLE=""                             # "y" indicates rpc port should be set at start
RPC_BASE_PORT=30000                       # the base is the port ID for the first node started with RPC_ENABLE enabled in a call
NODE_BASE_PORT=50000                      # the RPC_PORT becomes node port - NODE_BASE_PORT + RPC_BASE_PORT
RPC_SUPPORT_CHECK_RESULT=""               # "y" indicates JSON processor jq is available (set automatically in code below)

#if xhost >& /dev/null ; then readonly HAVEDISP="y" ; fi # check if display server is running to replace TUI by GUI

#######################################################################################################################
# Core functions extracting and caching information about sn nodes
########################################################################################################################

# usage: get_active_sn_pid <PEER_ID>      # Requires node to be running with a PID
get_and_store_active_sn_pid() {
  local __PEER_ID="$1"
  local __PID=""
  if [ -f "$NODE_DIR$__PEER_ID/PID" ]; then
    __PID=$(cat "$NODE_DIR$__PEER_ID/PID")
    if [[ "$__PID" -gt 0 ]]; then         # check if still alive
      local __PSPID
      __PSPID=$(ps -A | grep "safenode" | grep -E -o "($__PID) ")
      if [[ "$__PSPID" -ne "$__PID" ]]; then
        #__PSPID=$(ps -A | grep "safenode" | grep -o "[0-9]*" | head -1)
        __PSPID=$(lsof -X "$NODE_DIR$__PEER_ID/logs/safenode.log" | grep "safenode " | grep -o "[0-9]*" | head -1)
        if [[ "$__PSPID" -gt 0 ]]; then
          echo "WARNING: PID $__PID in cache was not found running! Actual PID seems to be $__PSPID. Updating cache." >&2
          __PID="$__PSPID"
        else
          echo "WARNING: PID $__PID in cache was not found running! Updating cache (deletion)." >&2
          __PID=""
          mv "$NODE_DIR$__PEER_ID/PID" "$NODE_DIR$__PEER_ID/STOPPED"
        fi
      fi
    else
      mv "$NODE_DIR$__PEER_ID/PID" "$NODE_DIR$__PEER_ID/STOPPED"
    fi
  else
    if [ -f "$NODE_DIR$__PEER_ID/logs/safenode.log" ]; then
      if [[ "$__PID" -le 0 ]]; then
        __PID=$(lsof -X "$NODE_DIR$__PEER_ID/logs/safenode.log" | grep "safenode " | grep -o "[0-9]*" | head -1)
      fi
    else
      echo "WARNING: Logfile $NODE_DIR$__PEER_ID/logs/safenode.log Not Found! Make sure logging is enabled at node start." >&2
    fi
  fi
  if [[ "$__PID" -gt 0 ]]; then
    echo "$__PID" > "$NODE_DIR$__PEER_ID/PID"
    if [ -f "$NODE_DIR$__PEER_ID/STOPPED" ]; then
      rm "$NODE_DIR$__PEER_ID/STOPPED"
    fi
    echo "$__PID"
  else
    if [ -f "$NODE_DIR$__PEER_ID/PID" ]; then
      mv "$NODE_DIR$__PEER_ID/PID" "$NODE_DIR$__PEER_ID/STOPPED"
    else
      touch "$NODE_DIR$__PEER_ID/STOPPED"
    fi
  fi
}

# usage: get_and_store_sn_port <PEER_ID>      # Requires node to be running with a PID or nothing will be returned
# can be slow executing due to the use of netstat. A side effect is get_and_store of pid if sn node is active.
get_and_store_sn_port(){
  local __PEER_ID="$1"
  local __PID
  local __PORT
  __PID=$(get_and_store_active_sn_pid "$__PEER_ID")
  if [[ "$__PID" -gt 0 ]]; then
    __PORT=$(netstat -lnup 2> /dev/null | grep "$__PID/safenode" | grep -o "[0-9]*" | head -7 | tail -n1)
    if [[ "$__PORT" -gt 0 ]]; then
      echo "$__PORT" > "$NODE_DIR$__PEER_ID/PORT"
      echo "$__PORT"
    fi
  fi
}

# usage: get_sn_pid <PEER_ID>         # Returns pid including check if still active,or tries to get it of a new active sn
get_sn_pid() {
  local __PEER_ID="$1"
  local __PID=""
  if [ ! -f "$NODE_DIR$__PEER_ID/PID" ]; then
    if [ ! -f "$NODE_DIR$__PEER_ID/STOPPED" ]; then
      get_and_store_active_sn_pid "$__PEER_ID"
    fi
  else
    if [ -f "$NODE_DIR$__PEER_ID/STOPPED" ]; then
      get_and_store_active_sn_pid "$__PEER_ID"
    fi
  fi
  if [ -f "$NODE_DIR$__PEER_ID/PID" ]; then
    __PID=$(cat "$NODE_DIR$__PEER_ID/PID")
    echo "$__PID"
  fi
}

# usage: get_sn_port <PEER_ID>              # If stored previously return port, else try to find it from a running node.
get_sn_port() {
  local __PEER_ID="$1"
  local __PORT=""
  [ ! -f "$NODE_DIR$__PEER_ID/PORT" ] && get_and_store_sn_port "$__PEER_ID"
  [ -f "$NODE_DIR$__PEER_ID/PORT" ] && __PORT=$(cat "$NODE_DIR$__PEER_ID/PORT")
  echo "$__PORT"
}

########################################################################################################################
# RPC support
########################################################################################################################

#usage: get_sn_rpc_address_for_pid <pid>
get_sn_rpc_address_for_pid(){
  local __RPC_ADDRESS
  local __PID="$1"
  if [[ ! -f "$NODE_DIR$__PEER_ID/RPCPORT" ]]; then
    __RPC_ADDRESS=$(netstat -tnlp 2> /dev/null | grep " $__PID/safenode " | grep -E -o "127.0.0.1:([0-9]*)")
    echo "$__RPC_ADDRESS" > "$NODE_DIR$__PEER_ID/RPCPORT"
  else
    __RPC_ADDRESS=$(cat "$NODE_DIR$__PEER_ID/RPCPORT");
    local __RESPONSE
    if [[ -n "$__RPC_ADDRESS" ]]; then
      __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/NodeInfo")
      if [[ ! -n "$__RESPONSE" ]]; then
        rm "$NODE_DIR$__PEER_ID/RPCPORT"
        __RPC_ADDRESS=""
      fi
    fi
  fi
  [[ -n "$__RPC_ADDRESS" ]] && echo "$__RPC_ADDRESS"
}

#usage: get_sn_rpc_info <rpc_address> <rpc_call> where <rpc_call> must be something like NodeInfo or NetworkInfo
get_sn_rpc_nodeinfo(){
  local __RPC_ADDRESS=$1
  local __RPC_CALL=$2
  local __RESPONSE=""
  if [[ -n "$__RPC_ADDRESS" && -n "$RPC_SUPPORT_CHECK_RESULT" ]]; then
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL")
    echo "$__RESPONSE"
  fi
}

#usage: get_sn_rpc_dump <rpc_address>
get_sn_rpc_dump(){
  local __RPC_ADDRESS=$1
  if [[ -n "$__RPC_ADDRESS" && -n "$RPC_SUPPORT_CHECK_RESULT" ]]; then
    local $__RPC_CALL
    __RPC_CALL="NodeInfo"
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL" | jq . )
    echo "$__RESPONSE"
    __RPC_CALL="NetworkInfo"
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL" | jq . )
    echo "$__RESPONSE"
    __RPC_CALL="RecordAddresses"
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL" | jq . )
    echo "$__RESPONSE"
    __RPC_CALL="KBuckets"
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL" | jq . )
    echo "$__RESPONSE"
  fi
}

########################################################################################################################
# Safenode-manager support
########################################################################################################################

#usage: Input should be a list such as that returned by $(ls path/)
snnm_extract_peer_id_list() {
  local __LIST=("$@")
  local __FILTERED_LIST=()
  for __PEER_ID in ${__LIST[@]}
  do
    if [ "${#__PEER_ID}" -eq "52" ] ;then        # peer-ids happen to be 52 characters long.
      __FILTERED_LIST+=( "$__PEER_ID" )
    else
      echo "omitting non-peer-id item $__PEER_ID"
    fi
  done
  echo "${__FILTERED_LIST[@]}"
}

########################################################################################################################
# Starting node functions
########################################################################################################################

#usage" snnm_node_starter ... <rpc-port is optional>
snnm_node_starter() {
  #NODE_DIR="$HOME/.local/share/safe/node/"
  local __OWNER_FLAG="--owner"
  local __PORT_FLAG="--port"
  local __RPC_FLAG="--rpc"
  local __PEER_ID_FLAG="--peer_id"
  local __MAXLOGS_FLAG="--max_log_files"
  local __MAXARCHLOGS_FLAG="--max_archived_log_files"
  local __PORT=""
  local ARGSLINE=""
  while [ "$#" -gt 1 ]; do
    case "$1" in
      "$__OWNER_FLAG")
        if [ ! "$2" = "none" ]; then
          ARGSLINE="$ARGSLINE $__OWNER_FLAG $2"
        fi
        ;;
      "$__PORT_FLAG")     ARGSLINE="$ARGSLINE $__PORT_FLAG $2"
                          __PORT=$2 ;;
      "$__RPC_FLAG")      ARGSLINE="$ARGSLINE $__RPC_FLAG $2" ;;
      "$__PEER_ID_FLAG")  ARGSLINE="$ARGSLINE --root-dir $NODE_DIR$2"
                          ARGSLINE="$ARGSLINE --log-output-dest $NODE_DIR$2/logs" ;;
      "$__MAXLOGS_FLAG")  ARGSLINE="$ARGSLINE $__MAXLOGS_FLAG=$2" ;;
      "$__MAXARCHLOGS_FLAG") ARGSLINE="$ARGSLINE $__MAXARCHLOGS_FLAG=$2" ;;
      *) echo "WARNING: Unrecognized argument name to snnm_node_starter: $1" >&2
    esac
    shift 2
  done
  echo "Target port: $__PORT (interactive mode:$INTERACTIVE; no_screen:$NO_SCREEN)..."
  if [ "$INTERACTIVE" = "y" ]; then
    ARGSLINE=$(whiptail --title "Node Toolbox" --inputbox "Edit arguments: " 10 80 "$ARGSLINE" 3>&1 1>&2 2>&3 )
  fi
  if [ "$NO_SCREEN" = "y" ]; then
    echo "Starting safenode $ARGSLINE & disown"
    eval "$SAFENODEPATH $ARGSLINE & disown"
  else
    echo "Starting screen -LdmS safenode$__PORT safenode $ARGSLINE"
    eval "screen -LdmS safenode$__PORT $SAFENODEPATH $ARGSLINE"
  fi
}

#######################################################################################################################
# CLI utility main functions
########################################################################################################################

snnm_update_cache() {
  echo "Updating cache with current sn status for new peer ids..."
  local __FILE_LIST
  local __CURRENT_DIR
  __CURRENT_DIR=$(pwd)
  __FILE_LIST=()
  local __FILE_COUNT
  __FILE_COUNT=$(ls "$NODE_DIR" | wc -l)
  if [[ "$__FILE_COUNT" -gt 0 ]]; then
    cd "$NODE_DIR" || exit 1
    __FILE_LIST=(*)
    cd "$__CURRENT_DIR" || exit 1
  fi
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  echo "Peer-id list to update: ${__FILE_LIST[@]}"
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      get_and_store_active_sn_pid "$__PEER_ID"
      local __PORT_CACHED
      if [ ! -f "$NODE_DIR$__PEER_ID/PORT" ]; then
        get_and_store_sn_port "$__PEER_ID"
        if [ -f "$NODE_DIR$__PEER_ID/PORT" ]; then
          __PORT_CACHED=$(cat "$NODE_DIR$__PEER_ID/PORT")
          echo "New peer: $__PEER_ID port: $__PORT_CACHED"
        else
          echo "Failed finding port, node is probably not running. Archive peer-id or restart interactively at an available port."
        fi
      fi
    fi
  done
}

#usage: snnm_list <optional start of port range overriding STARTPORT> <optional end of port range overriding ENDPORT>
# global NODE_DIR must be set
snnm_list() {
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  local __FILE_LIST
  __FILE_LIST=$(ls "$NODE_DIR")
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  local __PEERS_TOTAL="0"
  local __FORWARDED_TOTAL="0"
  local __RECORDS_TOTAL="0"
  local __ITEMS_LIST=()
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      [ -n "$RPC_SHOW" ] && echo -n "."
      local __PORT
      __PORT=$(get_sn_port "$__PEER_ID")
      if [[ $__PORT -le $__ENDPORT && $__PORT -ge $__STARTPORT ]]; then
        local __PID
        __PID=$(get_sn_pid "$__PEER_ID")
        local __RPC_INFO=""
        if [[ "$__PID" -gt 0 && -n "$RPC_SHOW" && -n "$RPC_SUPPORT_CHECK_RESULT" ]]; then
          local __RPC_ADDRESS
          __RPC_ADDRESS=$(get_sn_rpc_address_for_pid "$__PID")
          if [[ -n "$__RPC_ADDRESS" ]]; then
            local __RPC_JSON
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "NodeInfo" )
            local __RPC_BIN
            __RPC_BIN=$(echo "$__RPC_JSON" | jq -M .binVersion? )
            local __RPC_UPTIME
            __RPC_UPTIME=$(echo "$__RPC_JSON" | jq -M .uptimeSecs? )
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "NetworkInfo" )
            local __RPC_PEERS
            __RPC_PEERS=$(echo "$__RPC_JSON" | jq -M .connectedPeers? | wc -l )
            __PEERS_TOTAL=$((__PEERS_TOTAL+__RPC_PEERS))
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "RecordAddresses" )
            local __RPC_RECORDS
            __RPC_RECORDS=$(echo "$__RPC_JSON" | jq -M .addresses? | wc -l )
            __RECORDS_TOTAL=$((__RECORDS_TOTAL+__RPC_RECORDS))
            __RPC_INFO=$(printf "v.%-10s | %6s peers | %6s records | %10ss uptime | " "$__RPC_BIN" "$__RPC_PEERS" "$__RPC_RECORDS" "$__RPC_UPTIME")
          fi
        fi
        local __FORWARDED_BALANCE=""
        if [[ -f "$NODE_DIR$__PEER_ID/forwarded_balance" ]]; then
          __FORWARDED_BALANCE=$(cat "$NODE_DIR$__PEER_ID/forwarded_balance")
          __FORWARDED_TOTAL=$((__FORWARDED_TOTAL+__FORWARDED_BALANCE))
          __FORWARDED_BALANCE=$(printf "fwd_nanos: %s" "$__FORWARDED_BALANCE")
        fi
        local __ITEM
        __ITEM=$(printf "| port %6s | pid %8s | peer-id %s | %s$__FORWARDED_BALANCE\n" "$__PORT" "$__PID" "$__PEER_ID" "$__RPC_INFO")
        __ITEMS_LIST+=( "$__ITEM" )
      fi
    fi
  done
  [ -n "$RPC_SHOW" ] && echo ""
  local __ITEMS_SORTED=()
  IFS=$'\n' __ITEMS_SORTED=($(sort <<<"${__ITEMS_LIST[*]}")); unset IFS
  printf  '%s\n' "${__ITEMS_SORTED[@]}"
  [ -n "$RPC_SHOW" ] && printf "Total connected peers (nodes with rpc port only): %-10s Total records (nodes with rpc port only): %-10s Total forwarded nanos: %-16s\n" "$__PEERS_TOTAL" "$__RECORDS_TOTAL" "$__FORWARDED_TOTAL"
}

snnm_terminate(){
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  local __FILE_LIST
  __FILE_LIST=$(ls "$NODE_DIR")
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      local __PORT
      __PORT=$(get_sn_port "$__PEER_ID")
      if [[ $__PORT -le $__ENDPORT && $__PORT -ge $__STARTPORT ]]; then
        local __PID
        __PID=$(get_and_store_active_sn_pid "$__PEER_ID")
        if [[ $__PID -gt 0 ]]; then
          kill "$__PID" && echo "Killed node with peer id $__PEER_ID and pid $__PID running at port $__PORT."
          touch "$NODE_DIR$__PEER_ID/STOPPED"
        else
          echo "WARNING: $__PEER_ID node already stopped running at port $__PORT." >&2
        fi
      fi
    fi
  done
}

snnm_restart(){
  local __DISCORD_ID="$OWNER_DISCORD_ID"
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  local __FILE_LIST
  __FILE_LIST=$(ls "$NODE_DIR")
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      local __PORT
      __PORT=$(get_sn_port "$__PEER_ID")
      if [[ $__PORT -le $__ENDPORT && $__PORT -ge $__STARTPORT ]]; then
        local __PID
        __PID=$(get_and_store_active_sn_pid "$__PEER_ID")
        if [[ $__PID -gt 0 ]]; then
          echo "WARNING: $__PEER_ID node already running, at port $__PORT." >&2
        else
          echo "Restarting node with peer id $__PEER_ID running at port $__PORT."
          local __MAXLOGS="1"
          local __MAXARCHLOGS="0"
          local __RPC_PORT=""
          [ "$RPC_ENABLE" = "y" ] && __RPC_PORT=$((__PORT-NODE_BASE_PORT+RPC_BASE_PORT))
          if [[ $__RPC_PORT -gt 0 && ! $(netstat -tunlp | grep $__RPC_PORT) ]]; then
            echo "Restarting node with RPC_ENABLE at 127.0.0.1:$__RPC_PORT."
            snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__PORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS" "--peer_id" "$__PEER_ID" "--rpc" "127.0.0.1:$__RPC_PORT"
          else
            snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__PORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS" "--peer_id" "$__PEER_ID"
          fi
          sleep "$WAIT_SECS"
          snnm_update_cache
        fi
      fi
    fi
  done
}

snnm_terminate_and_restart() {
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  echo "Attempting to stop and restart node(s), exclusively for nodes that are currently running..."
  local __FILE_LIST
  __FILE_LIST=$(ls "$NODE_DIR")
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      local __PORT
      __PORT=$(get_sn_port "$__PEER_ID")
      if [[ $__PORT -le $__ENDPORT && $__PORT -ge $__STARTPORT ]]; then
        local __PID
        __PID=$(get_and_store_active_sn_pid "$__PEER_ID")
        if [[ $__PID -gt 0 ]]; then
          snnm_terminate $__PORT $__PORT
          sleep 2
          snnm_restart $__PORT $__PORT
        else
          echo "Skipping node with peer id $__PEER_ID because it is not running (port $__PORT)."
        fi
      fi
    fi
  done
}

snnm_start(){
  local __DISCORD_ID="$OWNER_DISCORD_ID"
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  for __TARGETPORT in $(seq "$__STARTPORT" "$__ENDPORT")
  do
    local __TARGET_PORT_FOUND=""
    echo "Exploring start on port number $__TARGETPORT..."
    local __FILE_LIST
    __FILE_LIST=$(ls "$NODE_DIR")
    local __PEER_ID_LIST
    __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
    for __PEER_ID in ${__PEER_ID_LIST[@]}
    do
      if [ -n "$__PEER_ID" ]; then
        local __PORT
        __PORT=$(get_sn_port "$__PEER_ID")
        if [[ $__PORT -eq $__TARGETPORT ]]; then
          echo "WARNING: $__TARGETPORT already associated with peer-id $__PEER_ID. Use restart instead if it is dead." >&2
          __TARGET_PORT_FOUND="$__PEER_ID"
        fi
      fi
    done
    if [ "$__TARGET_PORT_FOUND" == "" ]; then
      echo "Starting node with new peer id at port $__TARGETPORT."
      local __MAXLOGS=1
      local __MAXARCHLOGS=0
      local __RPC_PORT=""
      [ "$RPC_ENABLE" = "y" ] && __RPC_PORT=$((__TARGETPORT-NODE_BASE_PORT+RPC_BASE_PORT))
      if [[ $__RPC_PORT -gt 0 && ! $(netstat -tunlp | grep) ]]; then
        echo "Starting node with RPC_ENABLE at 127.0.0.1:$__RPC_PORT."
        snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__TARGETPORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS" "--rpc" "127.0.0.1:$__RPC_PORT"
      else
        snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__TARGETPORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS"
      fi
      sleep "$WAIT_SECS"
      snnm_update_cache
    fi
  done
}

snnm_archive_portless() {
  echo "Archiving all portless peer-ids..."
  local __FILE_LIST
  __FILE_LIST=$(ls "$NODE_DIR")
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      echo "Inspecting peer-id $__PEER_ID... "
      local __PORT
      __PORT=$(get_sn_port "$__PEER_ID")
      if [[ ! $__PORT -gt 0 ]]; then
        echo "Peer id $__PEER_ID will be archived: No know associated PORT and no node running to determine it."
        mkdir -p "$NODE_ARCHIVE_DIR"
        mv "$NODE_DIR$__PEER_ID" "$NODE_ARCHIVE_DIR$__PEER_ID"
      #else
        #echo "Associated port cached: $__PORT"
      fi
    fi
  done
}

snnm_archive_dead() {
  echo "Archiving all dead peer-ids..."
  local __FILE_LIST
  __FILE_LIST=$(ls "$NODE_DIR")
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      local __PID
      __PID=$(get_and_store_active_sn_pid "$__PEER_ID")
      if [[ $__PID -gt 0 ]]; then
        echo "$__PEER_ID node alive."
      else
        echo "Peer id $__PEER_ID not running (pid=$__PID) and will be archived."
        mkdir -p "$NODE_ARCHIVE_DIR"
        mv "$NODE_DIR$__PEER_ID" "$NODE_ARCHIVE_DIR$__PEER_ID"
      fi
    fi
  done
}

########################################################################################################################
# CLI options processing
########################################################################################################################

cmdline() {
  local arg=ARGS
  for arg
  do
    local delim=""
    case "$arg" in                                  # Translate --gnu-long-options to -g (short options)
      --help)           args="${args}-h ";;
      *) [[ "${arg:0:1}" == "-" ]] || delim="\""    # Pass through anything else
        args="${args}${delim}${arg}${delim} ";;
    esac
  done
  eval set -- $args                                 # Reset the positional parameters to the short options

  while getopts "Lecvqw:d:hma:b:niltsrxyzp:" OPTION      # Process options
  do
    case $OPTION in
      h) usage;
        exit 1;;
      v) echo "Version $VERSION";
        exit 0;;
      m) NODE_MANAGER="y"
         #NODE_DIR="$NODE_DIR_NODEMGR"
          ;;
      a) STARTPORT=${OPTARG} ;;
      b) ENDPORT=${OPTARG} ;;
      p) STARTPORT=${OPTARG}
         ENDPORT=${OPTARG} ;;
      d) OWNER_DISCORD_ID=${OPTARG} ;;
      w) WAIT_SECS=${OPTARG} ;;
      n) NO_SCREEN="y" ;;
      i) INTERACTIVE="y" ;;
      e) RPC_ENABLE="y" ;;
      q) set -x ;; #debug only
      l) COMMAND="y"
         snnm_list "$STARTPORT" "$ENDPORT" ;;
      L) COMMAND="y"
         local RPC_SHOW="y"
         snnm_list "$STARTPORT" "$ENDPORT" ;;
      c) COMMAND="y"
         snnm_update_cache ;;
      t) COMMAND="y"
         snnm_terminate "$STARTPORT" "$ENDPORT" ;;
      r) COMMAND="y"
         snnm_restart "$STARTPORT" "$ENDPORT" ;;
      x) COMMAND="y"
         snnm_terminate_and_restart "$STARTPORT" "$ENDPORT" ;;
      s) COMMAND="y"
         snnm_start "$STARTPORT" "$ENDPORT" ;;
      y) COMMAND="y"
         snnm_archive_dead ;;
      z) COMMAND="y"
         snnm_archive_portless ;;
      ?) echo "Invalid option found: -${OPTARG}. Check options with --help."
         exit 1 ;;
    esac
  done
  return 0
}

usage() {
  cat << EOF
$0 (v.$VERSION) is EXPERIMENTAL, use at your own risk!
USAGE: $0 [options and commands]

Manage safenode nodes directly

Options and commands are executed or applied in order of appearance. No command specified refreshes the cache.

OPTIONS:
   -h this help
   -p single port number of nodes to operate on
   -a start port number of nodes to operate on
   -b end port number of nodes to operate on
   -d set discord ID to use, or use none to disable, for all node (re)starts
   -w wait time in seconds between launch of new nodes
   -e enable RPC on node at (re)start for enhanced functionality. Computed as: PORT-NODE_BASE($NODE_BASE_PORT)+RPC_BASE($RPC_BASE_PORT)
   -n run new nodes without using screen, simply running as disowned process
   -i interactive mode, must precede the command switches it will apply to

COMMANDS:
   -l List nodes
   -c Update cache for all peer-ids which may take a long time
   -t Terminate nodes (-w option does not apply)
   -r Restart nodes that are not running at original ports
   -x eXchange; terminate and restart nodes at same ports
   -s Start nodes in a port range unless a port already is associated with an existing peer-id

COMMANDS with increased risk of breaking things, very much experimental at this time:
   -y archive all dead nodes (ignores any port restricting arguments) - MAY DISRUPT NODE STARTED IN UNSUPPORTED WAYS
   -z archive all nodes without port associated in cache (ignores any port restricting arguments)

EXAMPLE:
   $0 -a <lower_port_range_end> -b <upper_port_range_end> -d <discord_id> -w <pause_seconds> -s

NOTE:
   For all full functionality to be available install screen, whiptail, grpcurl and jq, and make sure that the
   .proto files safenode.proto and req_resp_types.proto are placed in $RPC_PROTO_PATH. The files can be downloaded here:
   https://github.com/maidsafe/safe_network/tree/main/sn_protocol/src/safenode_proto.

EOF
}

########################################################################################################################
# General logic
########################################################################################################################

command_exists() { if command -v "$1" > /dev/null 2>&1;
  then
    return 0
  else
    return 1
  fi
}
environment_check() {
  ! command_exists "safenode" && echo "TERMINATED: Requires safenode installed" && exit 1
  ! command_exists "netstat" && echo "TERMINADED: Requires netstat (net-tools) installed" && exit 1
  [ ! "$NO_SCREEN" = "y" ] && ! command_exists "screen" && echo "TERMINATED: Option requires screen installed" && exit 1
  [ "$INTERACTIVE" = "y" ] && ! command_exists "whiptail" && echo "TERMINATED: Option requires whiptail installed" && exit 1
  [ "$RPC_ENABLE" = "y" ] && ! command_exists "grpcurl" && echo "WARNING: To utilize RPC port on nodes you need grpcurl and .proto files installed"
  [ "$RPC_ENABLE" = "y" ] && command_exists "grpcurl" # check proto files at RPC_PROTO_PATH
  [ "$RPC_ENABLE" = "y" ] && ! command_exists "jq" && echo "WARNING: To utilize RPC related function you need jq installed"  # dnf install -y jq
  #enable functionality based on command availability
  command_exists "grpcurl" && command_exists "jq" && RPC_SUPPORT_CHECK_RESULT="y"
}

main() {
  environment_check   # prerequisites check
  mkdir -p "$NODE_DIR"
  if [ ! -d "$NODE_DIR" ]; then
    echo "Failed creating $NODE_DIR. Remedy before running snnm."
    exit 1
  fi
  cmdline "$@"        # pre-process cmd line parameters
  [ ! "$COMMAND" = "y" ] && snnm_update_cache #If no specific command was selected, update cached sn information
  echo "snnm execution is done. In some cases you need to [Ctrl]+[c] to get back to your command prompt."
  exit 0
}

# run only if script is not being sourced.
[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"