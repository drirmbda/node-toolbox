#!/bin/bash

#global variables readonly
readonly VERSION="0.3.2"
readonly ARGS=( "$@" )
OWNER_DISCORD_ID="none"                   # Disabled if "none". Set to your own ID as default (sorry if your ID is none)
STARTPORT=50000                           # Default lower end of port range, inclusive
ENDPORT=65535                             # Default upper end of port range, inclusive
RPC_BASE_PORT=30000                       # the base is the port ID for the first node started with RPC_ENABLE enabled in a call
NODE_BASE_PORT=50000                      # the RPC_PORT becomes node port - NODE_BASE_PORT + RPC_BASE_PORT
WAIT_SECS=10                              # Default wait between new node starts
SAFENODEPATH="$HOME/.local/bin/safenode"  # Default safenode binary, full path
NODE_DIR="$HOME/.local/share/safe/node"   # Default location of peer_id directories
SNNM_DIR="$NODE_DIR/../snnm"              # location for snnm cache
SNNM_BYPORT_DIR="$SNNM_DIR/by-port"       # location for snnm by-port links
SNNM_BYPEER_DIR="$SNNM_DIR/by-peerid"     # location for snnm by-port links
NODE_MANAGER=""                           # "y" indicates selection of safenode-manager use-case, not the default
INTERACTIVE=""                            # "y" indicates selection of interactive mode with TUI or GUI, not the default
COMMAND=""                                # "y" indicates a specific function was selected
RPC_PROTO_PATH="$HOME"                    # Default location of .proto files compatible with safenode binary
RPC_ENABLE=""                             # "y" indicates rpc port should be set at start
RPC_SUPPORT_CHECK_RESULT=""               # "y" indicates JSON processor jq is available (set automatically in code below)

#if xhost >& /dev/null ; then readonly HAVEDISP="y" ; fi # check if display server is running to replace TUI by GUI

#######################################################################################################################
# Core functions extracting and caching information about sn nodes
########################################################################################################################

# usage: get_active_sn_pid <PEER_ID>      # Requires node to be running with a PID
get_and_store_active_sn_pid() {
  local __PEER_ID="$1"
  local __PID=""
  if [ -f "$NODE_DIR/$__PEER_ID/PID" ]; then
    __PID=$(cat "$NODE_DIR/$__PEER_ID/PID")
    if [[ "$__PID" -gt 0 ]]; then         # check if still alive
      local __PSPID
      __PSPID=$(ps -A | grep "safenode" | grep -E -o "($__PID) ")
      if [[ "$__PSPID" -ne "$__PID" ]]; then
        #__PSPID=$(lsof -X "$NODE_DIR/$__PEER_ID/logs/safenode.log" | grep "safenode " | grep -o "[0-9]*" | head -1)
        __PSPID=$(lsof -X "$NODE_DIR/$__PEER_ID/logs/safenode.log" | grep "safenode " | grep -o "[0-9]*" | head -1)
        if [[ "$__PSPID" -gt 0 ]]; then
          echo "WARNING: PID $__PID in cache was not found running! Actual PID seems to be $__PSPID. Updating cache." >&2
          __PID="$__PSPID"
        else
          echo "WARNING: PID $__PID in cache was not found running! Updating cache (deletion)." >&2
          __PID=""
          mv "$NODE_DIR/$__PEER_ID/PID" "$NODE_DIR/$__PEER_ID/STOPPED"
        fi
      fi
    else
      mv "$NODE_DIR/$__PEER_ID/PID" "$NODE_DIR/$__PEER_ID/STOPPED"
    fi
  else
    if [ -f "$NODE_DIR/$__PEER_ID/logs/safenode.log" ]; then
      if [[ "$__PID" -le 0 ]]; then
        __PID=$(lsof -X "$NODE_DIR/$__PEER_ID/logs/safenode.log" | grep "safenode " | grep -o "[0-9]*" | head -1)
      fi
    else
      echo "WARNING: Logfile $NODE_DIR/$__PEER_ID/logs/safenode.log Not Found! Make sure logging is enabled at node start." >&2
    fi
  fi
  if [[ "$__PID" -gt 0 ]]; then
    echo "$__PID" > "$NODE_DIR/$__PEER_ID/PID"
    if [ -f "$NODE_DIR/$__PEER_ID/STOPPED" ]; then
      rm "$NODE_DIR/$__PEER_ID/STOPPED"
    fi
    echo "$__PID"
  else
    if [ -f "$NODE_DIR/$__PEER_ID/PID" ]; then
      mv "$NODE_DIR/$__PEER_ID/PID" "$NODE_DIR/$__PEER_ID/STOPPED"
    else
      touch "$NODE_DIR/$__PEER_ID/STOPPED"
    fi
  fi
}

# usage: get_and_store_sn_port <PEER_ID>      # Requires node to be running with a PID or nothing will be returned
# can be slow executing due to the use of netstat. A side effect is get_and_store of pid if sn node is active.
get_and_store_sn_port(){
  local __PEER_ID="$1"
  local __PID
  local __PORT
  __PID=$(get_and_store_active_sn_pid "$__PEER_ID")
  if [[ "$__PID" -gt 0 ]]; then
    __PORT=$(netstat -lnup 2> /dev/null | grep "$__PID/safenode" | grep -o "[0-9]*" | head -7 | tail -n1)
    if [[ "$__PORT" -gt 0 ]]; then
      echo "$__PORT" > "$NODE_DIR/$__PEER_ID/PORT"
      echo "$__PORT"
    fi
  fi
}

# usage: get_sn_pid <PEER_ID>         # Returns pid including check if still active,or tries to get it of a new active sn
get_sn_pid() {
  local __PEER_ID="$1"
  local __PID=""
  if [ ! -f "$NODE_DIR/$__PEER_ID/PID" ]; then
    if [ ! -f "$NODE_DIR/$__PEER_ID/STOPPED" ]; then
      get_and_store_active_sn_pid "$__PEER_ID"
    fi
  else
    if [ -f "$NODE_DIR/$__PEER_ID/STOPPED" ]; then
      get_and_store_active_sn_pid "$__PEER_ID"
    fi
  fi
  if [ -f "$NODE_DIR/$__PEER_ID/PID" ]; then
    __PID=$(cat "$NODE_DIR/$__PEER_ID/PID")
    echo "$__PID"
  fi
}

# usage: get_sn_port <PEER_ID>              # If stored previously return port, else try to find it from a running node.
get_sn_port() {
  local __PEER_ID="$1"
  local __PORT=""
  [ ! -f "$NODE_DIR/$__PEER_ID/PORT" ] && __PORT=$(get_and_store_sn_port "$__PEER_ID")
  [ -f "$NODE_DIR/$__PEER_ID/PORT" ] && __PORT=$(cat "$NODE_DIR/$__PEER_ID/PORT")
  echo "$__PORT"
}

########################################################################################################################
# RPC support
########################################################################################################################

#usage: get_sn_rpc_address_for_pid <pid> <peer id>
get_sn_rpc_address_for_pid(){
  local __RPC_ADDRESS
  local __PID="$1"
  local __PEER_ID="$2"
  if [[ ! -f "$NODE_DIR/$__PEER_ID/RPCPORT" ]]; then
    __RPC_ADDRESS=$(netstat -tnlp 2> /dev/null | grep " $__PID/safenode " | grep -E -o "127.0.0.1:([0-9]*)")
    echo "$__RPC_ADDRESS" > "$NODE_DIR/$__PEER_ID/RPCPORT"
  else
    __RPC_ADDRESS=$(cat "$NODE_DIR/$__PEER_ID/RPCPORT");
    local __RESPONSE
    if [[ -n "$__RPC_ADDRESS" ]]; then
      __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/NodeInfo")
      if [[ -z "$__RESPONSE" ]]; then
        rm "$NODE_DIR/$__PEER_ID/RPCPORT"
        __RPC_ADDRESS=""
      fi
    else
      __RPC_ADDRESS=$(netstat -tnlp 2> /dev/null | grep " $__PID/safenode " | grep -E -o "127.0.0.1:([0-9]*)")
      echo "$__RPC_ADDRESS" > "$NODE_DIR/$__PEER_ID/RPCPORT"
    fi
  fi
  [[ -n "$__RPC_ADDRESS" ]] && echo "$__RPC_ADDRESS"
}

#usage: get_sn_rpc_info <rpc_address> <rpc_call> where <rpc_call> must be something like NodeInfo or NetworkInfo
get_sn_rpc_nodeinfo(){
  local __RPC_ADDRESS=$1
  local __RPC_CALL=$2
  local __RESPONSE=""
  if [[ -n "$__RPC_ADDRESS" && -n "$RPC_SUPPORT_CHECK_RESULT" ]]; then
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL")
    echo "$__RESPONSE"
  fi
}

#usage: get_sn_rpc_dump <rpc_address>
get_sn_rpc_dump(){
  local __RPC_ADDRESS=$1
  if [[ -n "$__RPC_ADDRESS" && -n "$RPC_SUPPORT_CHECK_RESULT" ]]; then
    local __RPC_CALL
    __RPC_CALL="NodeInfo"
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL" | jq . )
    echo "$__RESPONSE"
    __RPC_CALL="NetworkInfo"
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL" | jq . )
    echo "$__RESPONSE"
    __RPC_CALL="RecordAddresses"
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL" | jq . )
    echo "$__RESPONSE"
    __RPC_CALL="KBuckets"
    __RESPONSE=$(grpcurl -plaintext -import-path "$RPC_PROTO_PATH" -proto "safenode.proto" -proto "req_resp_types.proto" "$__RPC_ADDRESS" "safenode_proto.SafeNode/$__RPC_CALL" | jq . )
    echo "$__RESPONSE"
  fi
}

########################################################################################################################
# New SNNM cache
########################################################################################################################

#grab all port information related to processes named safenode. This operation can be very expensive. Useful to get port for PID
update_netstat() {
  netstat -lnup 2> /dev/null | grep safenode > "$SNNM_DIR/netstat"
}

#grab all open file information. This operation can be very expensive and should be used sparingly. Useful to get PID for file.
update_lsof() {
  lsof -X "$NODE_DIR"/*/logs/safenode.log > "$SNNM_DIR/lsof"    # lsof -X "$NODE_DIR/$__PEER_ID/logs/safenode.log" | grep "safenode " | grep -o "[0-9]*" | head -1
}

#grab all processes named safenode. Useful to extract arguments of process such as owner, port, rpc port, etc.
update_ps() {
  pgrep -a safenode > "$SNNM_DIR/ps"
}

get_pid_from_peerid_commandline(){
  local __PEER_ID="$1"
  [ -n "$__PEER_ID" ] && pgrep -a safenode | grep "$__PEER_ID" | grep -o "[0-9]*" | head -1
}

get_pid_from_port_commandline(){
  local __PORT="$1"
  [ -n "$__PORT" ] && pgrep -a safenode | grep "\-\-port $__PORT" | grep -o "[0-9]*" | head -1
}

#can also use PID instead
get_owner_from_peerid_commandline(){
  local __PEER_ID="$1"
  [ -n "$__PEER_ID" ] && pgrep -a safenode | grep "$__PEER_ID" | grep -oP "(?<=--owner )[^\s]*"
}

#can also use PID instead
get_port_from_peerid_commandline(){
  local __PEER_ID="$1"
  [ -n "$__PEER_ID" ] && pgrep -a safenode | grep "$__PEER_ID" | grep -oP "(?<=--port )[0-9]*"
}

#can also use PID instead
get_rpc_from_peerid_commandline(){
  local __PEER_ID="$1"
  [ -n "$__PEER_ID" ] && pgrep -a safenode | grep "$__PEER_ID" | grep -oP "(?<=--rpc )[0-9,.,:]*"
}

get_rootdir_from_pid_commandline(){
  local __PID="$1"
  [ -n "$__PID" ] && pgrep -a safenode | grep "$__PID" | grep -oP "(?<=--root-dir )[^\s]*"
}

#creates an entry in the by-port directory named port number to the corresponding node directory
symlink_cache_byport_to_peernodedir(){
  local __NODE_PEER_PATH="$1"
  local __PORT="$2"
  if [ -n "$__PORT" ]; then
    [ -L "$SNNM_BYPORT_DIR/$__PORT" ] && rm "$SNNM_BYPORT_DIR/$__PORT"
    ln -s "$__NODE_PEER_PATH" "$SNNM_BYPORT_DIR/$__PORT"
  fi
}

#creates an entry in the by-port directory named port number to the corresponding node directory
symlink_cache_bypeerid_to_peernodedir(){
  local __NODE_PEER_PATH="$1"
  local __PEER_ID="$2"
  if [ -n "$__PEER_ID" ]; then
    [ -L "$SNNM_BYPEER_DIR/$__PEER_ID" ] && rm "$SNNM_BYPEER_DIR/$__PEER_ID"
    ln -s "$__NODE_PEER_PATH" "$SNNM_BYPEER_DIR/$__PEER_ID"
  fi
}

get_peernodedir_from_peernodedirpath(){
  local __PATH="$1"
  echo "$__PATH" | grep -oP "(?<=/node/)[^/]*"
}

get_peernodedir_from_pid(){
  local __PID="$1"
  ls -l /proc/"$__PID"/fd | grep safenode.log | grep -oP "(?<=/node/)[^/]*"
  #lsof -p "$__PID" | grep safenode.log | grep -oP "(?<=/node/)[^/]*"   #better but slower
}

get_peernodedir_from_terminal(){
  local __TMPFILE="$1"
  # shellcheck disable=SC2002
  cat "$__TMPFILE" | grep -oP "(?<=PeerId is )[^ ]*"  # alternative is "(?<=--peer-id=)[^\`]*"
}

set_cached_argsline(){
  local __PEER_ID="$1"
  local __ARGSLINE="$2"
  echo "$__ARGSLINE" > "$NODE_DIR/$__PEER_ID/STARTARGS"
}

set_cached_pid() {
  local __PEER_ID="$1"
  local __PID="$2"
  echo "$__PID" > "$NODE_DIR/$__PEER_ID/PID"
}

get_cached_pid() {
  local __PEER_ID="$1"
  [ -f "$NODE_DIR/$__PEER_ID/PID" ] && cat "$NODE_DIR/$__PEER_ID/PID"
}

set_cached_port(){
  local __PEER_ID="$1"
  local __PORT="$2"
  echo "$__PORT" > "$NODE_DIR/$__PEER_ID/PORT"
}

get_cached_port(){
  local __PEER_ID="$1"
  [ -f "$NODE_DIR/$__PEER_ID/PORT" ] && cat "$NODE_DIR/$__PEER_ID/PORT"
}

set_cached_peerid(){
  local __PEER_ID="$1"
  echo "$__PEER_ID" > "$NODE_DIR/$__PEER_ID/PEER-ID"
}

set_cached_rpc(){
  local __PEER_ID="$1"
  local __RPC="$2"
  echo "$__RPC" > "$NODE_DIR/$__PEER_ID/RPC"
}

get_cached_rpc() {
  local __PEER_ID="$1"
  [ -f "$NODE_DIR/$__PEER_ID/RPC" ] && cat "$NODE_DIR/$__PEER_ID/RPC"
}

set_cached_owner(){
  local __PEER_ID="$1"
  local __OWNER="$2"
  echo "$__OWNER" > "$NODE_DIR/$__PEER_ID/OWNER"
}

########################################################################################################################
# Checking of open ports and other features
########################################################################################################################

#usage example: A=$(is_occupied_udp <port>) ; [[ $A -gt 0 ]]  && echo "yes it is!"
is_occupied_udp(){
  local __PORT="$1"
  timeout 0.1 nc -l -u -p "$__PORT" > /dev/null 2>&1
  if [ "$?" -lt 124 ]; then
    echo "1" #occupied
  else
    echo "0"
  fi
}

is_occupied_tcp(){
  local __PORT="$1"
  timeout 0.1 nc -l -t -p "$__PORT" > /dev/null 2>&1
  if [ "$?" -lt 124 ]; then
    echo "1" #occupied
  else
    echo "0"
  fi
}

########################################################################################################################
# Safenode-manager support
########################################################################################################################

#usage: Input should be a list such as that returned by $(ls path/)
snnm_extract_peer_id_list() {
  local __LIST=("$@")
  local __FILTERED_LIST=()
  for __PEER_ID in ${__LIST[@]}
  do
    if [ "${#__PEER_ID}" -eq "52" ] ;then        # peer-ids happen to be 52 characters long.
      __FILTERED_LIST+=( "$__PEER_ID" )
    else
      echo "omitting non-peer-id item $__PEER_ID" >&2
    fi
  done
  echo "${__FILTERED_LIST[@]}"
}

########################################################################################################################
# Starting node functions
########################################################################################################################

#usage" snnm_node_starter ... <rpc-port is optional>
snnm_node_starter() {
  #NODE_DIR="$HOME/.local/share/safe/node"
  local __OWNER_FLAG="--owner"
  local __PORT_FLAG="--port"
  local __RPC_FLAG="--rpc"
  local __PEER_ID_FLAG="--peer_id"
  local __MAXLOGS_FLAG="--max_log_files"
  local __MAXARCHLOGS_FLAG="--max_archived_log_files"
  local __PORT=""
  local __RPC=""
  local __OWNER=""
  local ARGSLINE=""
  while [ "$#" -gt 1 ]; do
    case "$1" in
      "$__OWNER_FLAG")
        if [ ! "$2" = "none" ]; then
          ARGSLINE="$ARGSLINE $__OWNER_FLAG $2"
          __OWNER="$2"
        fi
        ;;
      "$__PORT_FLAG")     ARGSLINE="$ARGSLINE $__PORT_FLAG $2"
                          __PORT=$2 ;;
      "$__RPC_FLAG")      ARGSLINE="$ARGSLINE $__RPC_FLAG $2"
                          __RPC=$2 ;;
      "$__PEER_ID_FLAG")  ARGSLINE="$ARGSLINE --root-dir $NODE_DIR/$2"
                          ARGSLINE="$ARGSLINE --log-output-dest $NODE_DIR/$2/logs" ;;
      "$__MAXLOGS_FLAG")  ARGSLINE="$ARGSLINE $__MAXLOGS_FLAG=$2" ;;
      "$__MAXARCHLOGS_FLAG") ARGSLINE="$ARGSLINE $__MAXARCHLOGS_FLAG=$2" ;;
      *) echo "WARNING: Unrecognized argument name to snnm_node_starter: $1" >&2
    esac
    shift 2   #move $1 and $2 on to point to next args pair
  done
  echo "Target port: $__PORT RPC: $__RPC (interactive mode:$INTERACTIVE)..."
  if [ "$INTERACTIVE" = "y" ]; then
    ARGSLINE=$(whiptail --title "Node Toolbox" --inputbox "Edit arguments: " 10 80 "$ARGSLINE" 3>&1 1>&2 2>&3 )
  fi
  echo "Starting safenode $ARGSLINE & disown"
  local __PID
  eval "$SAFENODEPATH $ARGSLINE > /tmp/safenodeout-$__PORT & disown"
  __PID="$!"        #get the pid of the safenode. This must directly follow eval command to capture the correct pid
  sleep 1 #if this does not work then monitor file creation with a timeout.
  cat "/tmp/safenodeout-$__PORT"
  local __PEER_ID=""
  #__PEER_ID=$(get_peernodedir_from_pid "$__PID")
  local __PEER_ID_TERMINAL
  __PEER_ID_TERMINAL=$(get_peernodedir_from_terminal "/tmp/safenodeout-$__PORT")
  [ -z "$__PEER_ID" ] && __PEER_ID="$__PEER_ID_TERMINAL"
  [ -z "$__PEER_ID" ] && echo "FATAL: For port $__PORT failed to extract PEER_ID from pid $__PID or terminal output file $__PEER_ID_TERMINAL" && exit 1
  if [ -d "$NODE_DIR/$__PEER_ID" ]; then
    set_cached_argsline "$__PEER_ID" "$ARGSLINE"
    set_cached_pid "$__PEER_ID" "$__PID"
    set_cached_port "$__PEER_ID" "$__PORT"
    symlink_cache_byport_to_peernodedir "$NODE_DIR/$__PEER_ID" "$__PORT"
    set_cached_peerid "$__PEER_ID"
    symlink_cache_bypeerid_to_peernodedir "$NODE_DIR/$__PEER_ID" "$__PEER_ID"
    set_cached_rpc "$__PEER_ID" "$__RPC"
    set_cached_owner "$__PEER_ID" "$__OWNER"
  else
    echo "WARNING: logging directory expected for peerid $__PEER_ID not found."
  fi
}

#This requires ps, netstat and lsof outputs to be cached before use. Active nodes at port override any other nodes claiming port but not running.
snnm_pullin_legacy_active_nodes(){
  echo "Updating cache with current sn status for new peer ids, based on cached ps, lsof, netstat output."
  [[ ! -f "$SNNM_DIR/lsof" ]] && echo "File $SNNM_DIR/lsof not found. Use -j for this (slow!)." && return 1
  [[ ! -f "$SNNM_DIR/netstat" ]] && echo "File $SNNM_DIR/netstat not found. Use -j for this (slow!)." && return 1
  update_ps # psgep all active nodes to cache in $SNNM_DIR/ps
  # shellcheck disable=SC2002
  cat "$SNNM_DIR/ps" | while IFS= read -r LINE
  do
    if [ -n "$LINE" ]; then
      echo "$LINE"
      local __PID
      __PID=$(echo "$LINE" | grep -o "^[0-9]*")  #from ps list
      local __PEER_ID
      __PEER_ID=$(cat "$SNNM_DIR/lsof" | grep " $__PID " | grep -oP "(?<=/node/)[/]?[^/]*" | tr -d "/")  #from open files list
      if [ -n "$__PEER_ID" ]; then
        local __PORT_NETSTAT
        __PORT_NETSTAT=$(cat "$SNNM_DIR/netstat" | grep " $__PID/safenode" | grep -oP "(?<=0.0.0.0:)[0-9]*")  #from network ports list
        local __PORT_PS
        __PORT_PS=$(cat "$SNNM_DIR/ps" | grep "^$__PID " | grep -oP "(?<=--port )[0-9]*")
        if [ "$__PORT_PS" -ne "$__PORT_NETSTAT" ]; then
          echo "Inconsistent port numbers between ps ($__PORT_PS) and netstat ($__PORT_NETSTAT). Using netstat."
        fi
        local __PORT
        __PORT="$__PORT_NETSTAT"
        local __RPC
        __RPC=$(cat "$SNNM_DIR/ps" | grep "^$__PID " | grep -oP "(?<=--rpc )[0-9,.,:]*")
        local __OWNER
        __OWNER=$(cat "$SNNM_DIR/ps" | grep "^$__PID " | grep -oP "(?<=--owner )[^\s]*")
        local ARGSLINE
        ARGSLINE="$LINE"
        if [ -d "$NODE_DIR/$__PEER_ID" ]; then
          set_cached_argsline "$__PEER_ID" "$ARGSLINE"
          set_cached_pid "$__PEER_ID" "$__PID"
          set_cached_port "$__PEER_ID" "$__PORT"
          symlink_cache_byport_to_peernodedir "$NODE_DIR/$__PEER_ID" "$__PORT"
          set_cached_peerid "$__PEER_ID"
          symlink_cache_bypeerid_to_peernodedir "$NODE_DIR/$__PEER_ID" "$__PEER_ID"
          set_cached_rpc "$__PEER_ID" "$__RPC"
          set_cached_owner "$__PEER_ID" "$__OWNER"
        else
          echo "WARNING: logging directory expected for peerid $__PEER_ID but not found."
        fi
      else
        echo "WARNING: PID ($__PID) with no PEERID in lsof output."
      fi
    fi
  done
}

snnm_pullin_legacy_stopped_nodes(){
  local __FILE_LIST
  __FILE_LIST=$(ls "$NODE_DIR/")
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  local __PEERS_TOTAL="0"
  local __FORWARDED_TOTAL="0"
  local __RECORDS_TOTAL="0"
  local __ITEMS_LIST=()
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      local __PORT
      __PORT=$(get_cached_port "$__PEER_ID")
      if [ -n "$__PORT" ]; then
        if [ -d "$NODE_DIR/$__PEER_ID" ]; then
          #set_cached_argsline "$__PEER_ID" "$ARGSLINE"
          #set_cached_pid "$__PEER_ID" "$__PID"
          set_cached_port "$__PEER_ID" "$__PORT"
          symlink_cache_byport_to_peernodedir "$NODE_DIR/$__PEER_ID" "$__PORT"
          set_cached_peerid "$__PEER_ID"
          symlink_cache_bypeerid_to_peernodedir "$NODE_DIR/$__PEER_ID" "$__PEER_ID"
          #set_cached_rpc "$__PEER_ID" "$__RPC"
          #set_cached_owner "$__PEER_ID" "$__OWNER"
        else
          echo "WARNING: logging directory expected for peerid $__PEER_ID but not found."
        fi
      fi
    fi
  done
}

#######################################################################################################################
# CLI utility main functions
########################################################################################################################

#usage: snnm_list <optional start of port range overriding STARTPORT> <optional end of port range overriding ENDPORT>
# global NODE_DIR must be set
snnm_list() {
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  local __FILE_LIST
  __FILE_LIST=$(ls "$NODE_DIR/")
  local __PEER_ID_LIST
  __PEER_ID_LIST=$(snnm_extract_peer_id_list "${__FILE_LIST[@]}")
  local __PEERS_TOTAL="0"
  local __FORWARDED_TOTAL="0"
  local __RECORDS_TOTAL="0"
  local __ITEMS_LIST=()
  for __PEER_ID in ${__PEER_ID_LIST[@]}
  do
    if [ -n "$__PEER_ID" ]; then
      [ -n "$RPC_SHOW" ] && echo -n "."
      local __PORT
      __PORT=$(get_sn_port "$__PEER_ID")
      if [[ $__PORT -le $__ENDPORT && $__PORT -ge $__STARTPORT ]]; then
        local __PID
        __PID=$(get_sn_pid "$__PEER_ID")
        local __RPC_INFO=""
        if [[ "$__PID" -gt 0 && -n "$RPC_SHOW" && -n "$RPC_SUPPORT_CHECK_RESULT" ]]; then
          local __RPC_ADDRESS
          __RPC_ADDRESS=$(get_sn_rpc_address_for_pid "$__PID" "$__PEER_ID")
          if [[ -n "$__RPC_ADDRESS" ]]; then
            local __RPC_JSON
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "NodeInfo" )
            local __RPC_BIN
            __RPC_BIN=$(echo "$__RPC_JSON" | jq -M .binVersion? )
            local __RPC_UPTIME
            __RPC_UPTIME=$(echo "$__RPC_JSON" | jq -M .uptimeSecs? )
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "NetworkInfo" )
            local __RPC_PEERS
            __RPC_PEERS=$(echo "$__RPC_JSON" | jq -M .connectedPeers[]? | wc -l )
            __PEERS_TOTAL=$((__PEERS_TOTAL+__RPC_PEERS))
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "RecordAddresses" )
            local __RPC_RECORDS
            __RPC_RECORDS=$(echo "$__RPC_JSON" | jq -M .addresses[]? | wc -l )
            __RECORDS_TOTAL=$((__RECORDS_TOTAL+__RPC_RECORDS))
            __RPC_INFO=$(printf "v.%-10s | %6s peers | %6s records | %10ss uptime | " "$__RPC_BIN" "$__RPC_PEERS" "$__RPC_RECORDS" "$__RPC_UPTIME")
          fi
        fi
        local __FORWARDED_BALANCE=""
        if [[ -f "$NODE_DIR/$__PEER_ID/forwarded_balance" ]]; then
          __FORWARDED_BALANCE=$(cat "$NODE_DIR/$__PEER_ID/forwarded_balance")
          __FORWARDED_TOTAL=$((__FORWARDED_TOTAL+__FORWARDED_BALANCE))
          __FORWARDED_BALANCE=$(printf "fwd_nanos: %s" "$__FORWARDED_BALANCE")
        fi
        local __ITEM
        __ITEM=$(printf "| port %6s | pid %8s | peer-id %s | %s$__FORWARDED_BALANCE\n" "$__PORT" "$__PID" "$__PEER_ID" "$__RPC_INFO")
        __ITEMS_LIST+=( "$__ITEM" )
      fi
    fi
  done
  [ -n "$RPC_SHOW" ] && echo ""
  local __ITEMS_SORTED=()
  IFS=$'\n' __ITEMS_SORTED=($(sort <<<"${__ITEMS_LIST[*]}")); unset IFS
  printf  '%s\n' "${__ITEMS_SORTED[@]}"
  [ -n "$RPC_SHOW" ] && echo "Total connected peers (for nodes with rpc port only): $__PEERS_TOTAL"
  [ -n "$RPC_SHOW" ] && echo "Total records (for nodes with rpc port only): $__RECORDS_TOTAL"
  [ -n "$RPC_SHOW" ] && echo "Total forwarded nanos: $__FORWARDED_TOTAL"
}

snnm_list_fast() { #OPTION -l assumes cache is synced to machine state
  echo "Listing nodes based on cached information and checking if processes are alive."
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  local __PEERS_TOTAL="0"
  local __FORWARDED_TOTAL="0"
  local __RECORDS_TOTAL="0"
  local __ITEMS_LIST=() #items collector before sorting
  for __PORT in $(seq "$__STARTPORT" 1 "$__ENDPORT" )
  do
   # [ -n "$RPC_SHOW" ] && echo -n "."
    if [ -d "$SNNM_BYPORT_DIR/$__PORT" ]; then
      local __PATH
      __PATH=$(realpath "$SNNM_BYPORT_DIR/$__PORT") #follow symlink
      local __PEER_ID
      __PEER_ID=$(get_peernodedir_from_peernodedirpath "$__PATH")
      if [ -n "$__PEER_ID" ]; then #make sure peer-id or node name is populated
        local __PID
        __PID=$(get_cached_pid "$__PEER_ID")
        local __PID_LIVE
        __PID_LIVE=$(get_pid_from_peerid_commandline "$__PEER_ID")
        [[ "$__PID" -ne "$__PID_LIVE" ]] && set_cached_pid "$__PEER_ID" "$__PID_LIVE" && __PID="$__PID_LIVE"
        local __RPC_INFO=""
        if [[ "$__PID" -gt 0 && -n "$RPC_SHOW" && -n "$RPC_SUPPORT_CHECK_RESULT" ]]; then
          local __RPC_ADDRESS
          __RPC_ADDRESS=$(get_cached_rpc "$__PEER_ID")
          if [[ -n "$__RPC_ADDRESS" ]]; then
            local __RPC_JSON
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "NodeInfo" )
            local __RPC_BIN
            __RPC_BIN=$(echo "$__RPC_JSON" | jq -M .binVersion? )
            local __RPC_UPTIME
            __RPC_UPTIME=$(echo "$__RPC_JSON" | jq -M .uptimeSecs? )
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "NetworkInfo" )
            local __RPC_PEERS
            __RPC_PEERS=$(echo "$__RPC_JSON" | jq -M .connectedPeers[]? | wc -l )
            __PEERS_TOTAL=$((__PEERS_TOTAL+__RPC_PEERS))
            __RPC_JSON=$(get_sn_rpc_nodeinfo "$__RPC_ADDRESS" "RecordAddresses" )
            local __RPC_RECORDS
            __RPC_RECORDS=$(echo "$__RPC_JSON" | jq -M .addresses[]? | wc -l )
            __RECORDS_TOTAL=$((__RECORDS_TOTAL+__RPC_RECORDS))
            __RPC_INFO=$(printf "v.%-10s | %6s peers | %6s records | %10ss uptime | " "$__RPC_BIN" "$__RPC_PEERS" "$__RPC_RECORDS" "$__RPC_UPTIME")
          fi
        fi
        local __FORWARDED_BALANCE=""
        if [[ -f "$NODE_DIR/$__PEER_ID/forwarded_balance" ]]; then
          __FORWARDED_BALANCE=$(cat "$NODE_DIR/$__PEER_ID/forwarded_balance")
          __FORWARDED_TOTAL=$((__FORWARDED_TOTAL+__FORWARDED_BALANCE))
          __FORWARDED_BALANCE=$(printf "fwd_nanos: %s" "$__FORWARDED_BALANCE")
        fi
        local __ITEM
        printf "| port %6s | pid %8s | peer-id %s | %s$__FORWARDED_BALANCE\n" "$__PORT" "$__PID" "$__PEER_ID" "$__RPC_INFO"
      else
        echo "WARNING: Port $__PORT in cache does not point to any node ($__PATH)."
      fi
    fi
  done
 # [ -n "$RPC_SHOW" ] && echo ""
 # local __ITEMS_SORTED=()
  #IFS=$'\n' __ITEMS_SORTED=($(sort <<<"${__ITEMS_LIST[*]}")); unset IFS
 # printf  '%s\n' "${__ITEMS_SORTED[@]}"
  [ -n "$RPC_SHOW" ] && echo "Total connected peers (for nodes with rpc port only): $__PEERS_TOTAL"
  [ -n "$RPC_SHOW" ] && echo "Total records (for nodes with rpc port only): $__RECORDS_TOTAL"
  echo "Total forwarded nanos: $__FORWARDED_TOTAL"
}

snnm_terminate_fast(){
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  local __FILE_LIST
  __FILE_LIST=$(ls "$SNNM_BYPORT_DIR/")
  for __PORT in ${__FILE_LIST[@]}
  do
    if [ -n "$__PORT" ]; then
      if [[ $__PORT -le $__ENDPORT && $__PORT -ge $__STARTPORT ]]; then
        local __PATH
        __PATH=$(realpath "$SNNM_BYPORT_DIR/$__PORT")
        __PEER_ID=$(get_peernodedir_from_peernodedirpath "$__PATH")
        local __PID
        __PID=$(get_pid_from_peerid_commandline "$__PEER_ID")
        if [[ $__PID -gt 0 ]]; then
          kill "$__PID" && echo "Killed node with peer id $__PEER_ID and pid $__PID running at port $__PORT."
          touch "$NODE_DIR/$__PEER_ID/STOPPED"
        else
          __PID=$(get_pid_from_port_commandline "$__PORT")
          if [[ $__PID -gt 0 ]]; then
            kill "$__PID" && echo "Killed node with peer id $__PEER_ID and pid $__PID running at port $__PORT."
            touch "$NODE_DIR/$__PEER_ID/STOPPED"
          else
            echo "WARNING: $__PEER_ID node already stopped (port $__PORT)." >&2
          fi
        fi
      fi
    fi
  done
}

snnm_restart_fast(){
  local __DISCORD_ID="$OWNER_DISCORD_ID"
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  local __FILE_LIST
  __FILE_LIST=$(ls "$SNNM_BYPORT_DIR/")
  for __PORT in ${__FILE_LIST[@]}
  do
    if [ -n "$__PORT" ]; then
      if [[ $__PORT -le $__ENDPORT && $__PORT -ge $__STARTPORT ]]; then
        local __PORT_OCCUPIED
        __PORT_OCCUPIED=$(is_occupied_udp "$__PORT")
        if [ "$__PORT_OCCUPIED" -gt 0 ]; then
          echo "Skipping port $__PORT - it is already occupied."
        else
          local __PATH
          if [ -L "$SNNM_BYPORT_DIR/$__PORT" ] && [ -e "$SNNM_BYPORT_DIR/$__PORT" ]; then
            __PATH=$(realpath "$SNNM_BYPORT_DIR/$__PORT")
          else
            __PATH="" #symlink is invalid so ignore it.
          fi
          __PEER_ID=$(get_peernodedir_from_peernodedirpath "$__PATH")
          [ -z "$__PEER_ID" ] && echo "FATAL: For port $__PORT failed to extract PEER_ID from path $__PATH." && exit 1
          local __PID
          __PID=$(get_pid_from_peerid_commandline "$__PEER_ID")
          if [[ ! $__PID -gt 0 ]]; then
            __PID=$(get_pid_from_port_commandline "$__PORT")
          fi
          if [[ $__PID -gt 0 ]]; then
            echo "WARNING: $__PEER_ID node already running, at port $__PORT." >&2
          else
            echo "Restarting node with peer id $__PEER_ID running at port $__PORT."
            local __MAXLOGS="1"
            local __MAXARCHLOGS="0"
            local __RPC_PORT=""
            [ "$RPC_ENABLE" = "y" ] && __RPC_PORT=$((__PORT-NODE_BASE_PORT+RPC_BASE_PORT))
            if [[ $__RPC_PORT -gt 0 ]]; then
              local __RPC_OCCUPIED
              __RPC_OCCUPIED=$(is_occupied_tcp "$__RPC_PORT")
              if [ "$__RPC_OCCUPIED" -gt 0 ]; then
                echo "Starting port $__TARGETPORT without RPC at $__RPC_PORT - it is already occupied."
                snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__PORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS" "--peer_id" "$__PEER_ID"
              else
                snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__PORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS" "--peer_id" "$__PEER_ID" "--rpc" "127.0.0.1:$__RPC_PORT"
              fi
            else
              snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__PORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS" "--peer_id" "$__PEER_ID"
            fi
            sleep "$WAIT_SECS"
          fi
        fi
      fi
    fi
  done
}

snnm_terminate_and_restart_fast() {
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  echo "Attempting to stop and restart node(s), exclusively for nodes that are currently running..."
  for _PORT in $(seq "$__STARTPORT" 1 "$__ENDPORT")
  do
    if [ -L "$SNNM_BYPORT_DIR/$_PORT" ] && [ -e "$SNNM_BYPORT_DIR/$_PORT" ]; then
      snnm_terminate_fast "$_PORT" "$_PORT"
      sleep 2
      snnm_restart_fast "$_PORT" "$_PORT"
    fi
  done
}

#usage snnm_start <start port> <end port> # uses WAIT_SECS, OWNER_DISCORD_ID=drirmbda_73081, NODE_BASE_PORT=50000, RPC_BASE_PORT=30000
snnm_start_fast(){
  local __DISCORD_ID="$OWNER_DISCORD_ID"
  local __STARTPORT="$STARTPORT"
  local __ENDPORT="$ENDPORT"
  [ -n "$1" ] && __STARTPORT="$1"
  [ -n "$2" ] && __ENDPORT="$2"
  for __TARGETPORT in $(seq "$__STARTPORT" "$__ENDPORT")
  do
    echo "Starting node with new peer id at port $__TARGETPORT."
    local __PORT_OCCUPIED
    __PORT_OCCUPIED=$(is_occupied_udp "$__TARGETPORT")
    if [ "$__PORT_OCCUPIED" -gt 0 ]; then
      echo "Skipping port $__TARGETPORT - it is already occupied."
    else
      local __MAXLOGS=1
      local __MAXARCHLOGS=0
      local __RPC_PORT=""
      [ "$RPC_ENABLE" = "y" ] && __RPC_PORT=$((__TARGETPORT-NODE_BASE_PORT+RPC_BASE_PORT))
      if [[ $__RPC_PORT -gt 0 ]]; then
        local __RPC_OCCUPIED
        __RPC_OCCUPIED=$(is_occupied_tcp "$__RPC_PORT")
        if [ "$__RPC_OCCUPIED" -gt 0 ]; then
          echo "Starting port $__TARGETPORT without RPC at $__RPC_PORT - it is already occupied."
          snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__TARGETPORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS"
        else
          snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__TARGETPORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS" "--rpc" "127.0.0.1:$__RPC_PORT"
        fi
      else
        snnm_node_starter "--owner" "$__DISCORD_ID" "--port" "$__TARGETPORT" "--max_log_files" "$__MAXLOGS" "--max_archived_log_files" "$__MAXARCHLOGS"
      fi
      sleep "$WAIT_SECS"
    fi
  done
}

########################################################################################################################
# CLI options processing
########################################################################################################################

cmdline() {
  local arg=ARGS
  for arg
  do
    local delim=""
    case "$arg" in                                  # Translate --gnu-long-options to -g (short options)
      --help)           args="${args}-h ";;
      *) [[ "${arg:0:1}" == "-" ]] || delim="\""    # Pass through anything else
        args="${args}${delim}${arg}${delim} ";;
    esac
  done
  eval set -- $args                                 # Reset the positional parameters to the short options

  while getopts "sLecjvqKkw:d:hma:b:iltrxp:" OPTION      # Process options
  do
    case $OPTION in
      h) usage;
        exit 1;;
      v) echo "Version $VERSION";
        exit 0;;
      m) NODE_MANAGER="y"
         #NODE_DIR="$NODE_DIR_NODEMGR"
         ;;
      a) STARTPORT=${OPTARG} ;;
      b) ENDPORT=${OPTARG} ;;
      p) STARTPORT=${OPTARG}
         ENDPORT=${OPTARG} ;;
      d) OWNER_DISCORD_ID=${OPTARG} ;;
      w) WAIT_SECS=${OPTARG} ;;
      i) INTERACTIVE="y" ;;
      e) RPC_ENABLE="y" ;;
      q) set -x ;; #debug only
      l) COMMAND="y"
         snnm_list_fast "$STARTPORT" "$ENDPORT" ;;
      L) COMMAND="y"
         local RPC_SHOW="y"
         snnm_list_fast "$STARTPORT" "$ENDPORT" ;;
      k) COMMAND="y"
         snnm_list "$STARTPORT" "$ENDPORT" ;;   # Deprecated, old -l
      K) COMMAND="y"
         local RPC_SHOW="y"
         snnm_list "$STARTPORT" "$ENDPORT" ;;   # Deprecated, old -L
      j) COMMAND="y"
         update_netstat
         update_lsof ;;
      c) COMMAND="y"
         #snnm_update_cache ;; #legacy
         snnm_pullin_legacy_stopped_nodes
         snnm_pullin_legacy_active_nodes ;;
      t) COMMAND="y"
         snnm_terminate_fast "$STARTPORT" "$ENDPORT" ;;
      r) COMMAND="y"
         snnm_restart_fast "$STARTPORT" "$ENDPORT" ;;
      x) COMMAND="y"
         snnm_terminate_and_restart_fast "$STARTPORT" "$ENDPORT" ;;
      s) COMMAND="y"
         snnm_start_fast "$STARTPORT" "$ENDPORT" ;;
      ?) echo "Invalid option found: -${OPTARG}. Check options with --help."
         exit 1 ;;
    esac
  done
  return 0
}

usage() {
  cat << EOF
$0 (v.$VERSION) is EXPERIMENTAL, use at your own risk!
USAGE: $0 [options and commands]

Manage safenode nodes directly

Options and commands are executed or applied in order of appearance. No command specified refreshes the cache.

OPTIONS:
   -h this help
   -p single port number of nodes to operate on
   -a start port number of nodes to operate on
   -b end port number of nodes to operate on
   -d set discord ID to use, or use none to disable, for all node (re)starts
   -w wait time in seconds between launch of new nodes
   -e enable RPC on node at (re)start for enhanced functionality. Computed as: PORT-NODE_BASE($NODE_BASE_PORT)+RPC_BASE($RPC_BASE_PORT)
   -i interactive mode, must precede the command switches it will apply to

COMMANDS:
   -l List nodes
   -L List nodes with rpc call based details
   -j Update info cache for all peer-ids which may take a very long time on an overloaded system! This results in most complete info transfer using running nodes.
   -c Update ports cache without newly pulling information from ps lsof and netstat but using cached output generated with -j
   -T Terminate nodes fast (-w option does not apply)
   -r Restart nodes that are not running at original ports fast
   -x eXchange; terminate and restart nodes at same ports fast
   -s Start nodes in a port range unless a port already is associated with an existing peer-id
   -S Start nodes fast

EXAMPLE:
   $0 -a <lower_port_range_end> -b <upper_port_range_end> -d <discord_id> -w <pause_seconds> -e -S

NOTE:
   For all full functionality to be available install whiptail, grpcurl and jq, and make sure that the
   .proto files safenode.proto and req_resp_types.proto are placed in $RPC_PROTO_PATH. The files can be downloaded here:
   https://github.com/maidsafe/safe_network/tree/main/sn_protocol/src/safenode_proto.

EOF
}

# netstat should be replaced by ss if available.

########################################################################################################################
# General logic
########################################################################################################################

command_exists() { if command -v "$1" > /dev/null 2>&1;
  then
    return 0
  else
    return 1
  fi
}

environment_check() {
  ! command_exists "timeout" && echo "TERMINATED: Requires timeout installed" && exit 1   #needed for open port checking
  ! command_exists "safenode" && echo "TERMINATED: Requires safenode installed" && exit 1
  ! command_exists "netstat" && echo "TERMINADED: Requires netstat (net-tools) installed" && exit 1
  [ "$INTERACTIVE" = "y" ] && ! command_exists "whiptail" && echo "TERMINATED: Option requires whiptail installed" && exit 1
  [ "$RPC_ENABLE" = "y" ] && ! command_exists "grpcurl" && echo "WARNING: To utilize RPC port on nodes you need grpcurl and .proto files installed"
  [ "$RPC_ENABLE" = "y" ] && command_exists "grpcurl" # check proto files at RPC_PROTO_PATH
  [ -f "$RPC_PROTO_PATH/.local/bin/safenode.proto" ] && RPC_PROTO_PATH="$HOME/.local/bin"
  [ "$RPC_ENABLE" = "y" ] && ! command_exists "jq" && echo "WARNING: To utilize RPC related function you need jq installed"  # dnf install -y jq
  #enable functionality based on command availability
  command_exists "grpcurl" && command_exists "jq" && RPC_SUPPORT_CHECK_RESULT="y"
  [ -n "$RPC_SHOW" ] && [ ! -n "$RPC_SUPPORT_CHECK_RESULT" ] && echo "WARNING: RPC calls not enabled. Ensure grpcurl and jq are both installed."
  [ "$OWNER_DISCORD_ID" != "none" ] && echo "OWNER_DISCORD_ID is set to $OWNER_DISCORD_ID in the snnm script. To unset it, change it to none."
}

main() {
  environment_check   # prerequisites check
  mkdir -p "$NODE_DIR/"
  if [ ! -d "$NODE_DIR/" ]; then
    echo "Failed creating $NODE_DIR/. Remedy before running snnm."
    exit 1
  fi
  mkdir -p "$SNNM_DIR/"
  mkdir -p "$SNNM_BYPORT_DIR/"
  mkdir -p "$SNNM_BYPEER_DIR/"
  if [ ! -d "$SNNM_DIR/" ]; then
    echo "Failed creating $SNNM_DIR/. Remedy before running snnm."
    exit 1
  fi
  cmdline "$@"        # pre-process cmd line parameters
  echo "snnm execution is done. In some cases you need to [Ctrl]+[c] to get back to your command prompt."
  exit 0
}

# run only if script is not being sourced.
[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"